db:
[
    {
        "storeId": "1000",
        "storeName": "MILTON, ON",
        "storeNumber": "1000",
        "Province": "Ontario",
        "WM Region": "2",
        "Banner": "Walmart Supercenter",
        "Market": "11",
        "City": "Milton",
        "location": {
            "Province": "Ontario",
            "WM Region": "2",
            "Store Status": "Active",
            "Market": "11",
            "City": "Milton",
            "Banner": "Walmart Supercenter",
            "Original GO FY": "2005",
            "SC GO FY": "2009",
            "SC TYPE": "SC-Exp",
            "Age of Box": 18.47,
            "Last Touch Project Year": "FY24",
            "Last Touch Type": "RM-Full",
            "Last Touch Status": "Last Touch",
            "Template": "160k",
            "Total Store SQFT": 189376,
            "Acquisition History": "N/A",
            "Store Format BN": "No",
            "Store Format BCN": "Yes",
            "Store Format Div 1": "No",
            "Store Format SC": "No",
            "Original GO Date": "September 22, 2004",
            "SC GO Date": "October 2, 2008",
            "Last Touch GO Date": "January 31, 2024"
        },
        "building": {
            "Owned VS Leased": "Owned",
            "Mall Store": "Not Mall Store",
            "Mall Entrances": 0,
            "Security Entrance Gates": 0,
            "Shopping Centre Type": "Power Centre",
            "Asset Protection Security Room": "None",
            "Number of Floors": 1,
            "Basement": "No",
            "Receiving on Different Floor": "Yes",
            "Mezzanine": "N",
            "Freight Elevators": 0,
            "Customer Elevator Location": "N/A",
            "Vertical Transportation": "None",
            "Shopping Cart Movator": "No",
            "Cart Corral": "Vestibule"
        },
        "site": {
            "Accessible": "16",
            "Expecting Mother": "10",
            "Green Parking": "0",
            "Charging Stations": "0",
            "Cart Corral Exterior": "Covered",
            "Parking Location": "Grade"
        },
        "salesFloor": {
            "Food Location": "S",
            "Flooring": "Concrete (brown)",
            "Woodgrain": "Apparel/Shoes",
            "Garden Centre": "Standard",
            "Hose Bib": "Y"
        },
        "food": {
            "Sushi": "Yes",
            "Vendor": "QUEBEC INC.",
            "Service Deli": "Y",
            "Deli HMR Screens": "Y",
            "Bakery Location": "Backroom"
        },
        "omni": {
            "Parking Spaces": "12",
            "Orange Branding": "GM",
            "Direct Access": "2",
            "Van Loading": "0",
            "Mobile Check In": "Bollards"
        },
        "pharmacy": {
            "Location": "GM Entrance",
            "1 Tier or 2 Tier": "1",
            "Seating": "2",
            "Consultation Rooms": 1
        },
        "marketing": {
            "Minale": "Y",
            "Enchilada": "N",
            "Swipe Up": "N",
            "Pre Minale": "Y",
            "Lit Fitting Room": "N"
        },
        "backroomIsd": {
            "Loading Docks": "4",
            "Receiving Areas": "1",
            "Backroom Ceiling - Height": "N/A",
            "Backroom Ceiling - Multi-Height": "N",
            "High-Steel Pallet Spots": "77",
            "Cages/Lock-ups": 3,
            "CBL Terminals": "5"
        }
    },
    {
        "storeId": "1001",
        "storeName": "BOWMANVILLE, ON",
        "storeNumber": "1001",
        "Province": "Ontario",
        "WM Region": "4",
        "Banner": "Walmart Supercenter",
        "Market": "21",
        "City": "Bowmanville",
        "location": {
            "Province": "Ontario",
            "WM Region": "4",
            "Store Status": "Active",
            "Market": "21",
            "City": "Bowmanville",
            "Banner": "Walmart Supercenter",
            "Original GO FY": "2011",
            "SC GO FY": "2011",
            "SC TYPE": "SC-New",
            "Age of Box": 12.75,
            "Last Touch Project Year": "FY22",
            "Last Touch Type": "RM-Light",
            "Last Touch Status": "Last Touch",
            "Template": "160k",
            "Total Store SQFT": 154077,
            "Acquisition History": "N/A",
            "Store Format BN": "No",
            "Store Format BCN": "Yes",
            "Store Format Div 1": "No",
            "Store Format SC": "No",
            "Original GO Date": "June 10, 2010",
            "SC GO Date": "June 10, 2010",
            "Last Touch GO Date": "October 5, 2022"
        },
        "building": {
            "Owned VS Leased": "Leased",
            "Mall Store": "Not Mall Store",
            "Mall Entrances": 0,
            "Security Entrance Gates": 0,
            "Shopping Centre Type": "Neighbourhood",
            "Asset Protection Security Room": "Entrance",
            "Number of Floors": 1,
            "Basement": "No",
            "Receiving on Different Floor": "No",
            "Mezzanine": null,
            "Freight Elevators": 0,
            "Customer Elevator Location": null,
            "Vertical Transportation": "None",
            "Shopping Cart Movator": "No",
            "Cart Corral": null
        },
        "site": {
            "Accessible": null,
            "Expecting Mother": null,
            "Green Parking": null,
            "Charging Stations": null,
            "Cart Corral Exterior": null,
            "Parking Location": null
        },
        "salesFloor": {
            "Food Location": "S",
            "Flooring": null,
            "Woodgrain": null,
            "Garden Centre": "Standard",
            "Hose Bib": null
        },
        "food": {
            "Sushi": "No",
            "Vendor": "-",
            "Service Deli": null,
            "Deli HMR Screens": null,
            "Bakery Location": null
        },
        "omni": {
            "Parking Spaces": null,
            "Orange Branding": null,
            "Direct Access": null,
            "Van Loading": null,
            "Mobile Check In": null
        },
        "pharmacy": {
            "Location": null,
            "1 Tier or 2 Tier": null,
            "Seating": null,
            "Consultation Rooms": 1
        },
        "marketing": {
            "Minale": null,
            "Enchilada": null,
            "Swipe Up": null,
            "Pre Minale": null,
            "Lit Fitting Room": null
        },
        "backroomIsd": {
            "Loading Docks": null,
            "Receiving Areas": null,
            "Backroom Ceiling - Height": null,
            "Backroom Ceiling - Multi-Height": null,
            "High-Steel Pallet Spots": null,
            "Cages/Lock-ups": 0,
            "CBL Terminals": null
        }
    },


    index.js:
    import React from 'react';
import { useEffect, useState, useMemo } from 'react';
import NavBar from '../common/nav-bar';
import PageHeader from '../common/PageHeader';
import { getAllStoreAttributes } from '../../api/stores';
// import { mockStores } from './mockData/mockStores';

import LoadingLayout from '../common/Loading';
import PortfolioTable from './PortfolioTable';
import { Box } from '@mui/material';
import { tableConfig } from './mockData/tableConfig';

export default function Portfolio() {
  const [filters, setFilters] = useState({
    attributes: {}, // Tab-specific filters
  });

  const [stores, setStores] = useState([]); // State to hold API data
  const [loading, setLoading] = useState(true); // State to manage loading

  const breadcrumbs = [
    { name: 'Stores', href: '/stores' },
    { name: 'Portfolio View' },
  ];

  // Fetch data from the API
  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);
        const data = await getAllStoreAttributes(); // Call your API function
        setStores(data); // Update state with fetched data
      } catch (error) {
        console.error('Error fetching store attributes:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);
  // Filter stores based on selected filters
  const filteredStores = useMemo(() => {
    return stores.filter((store) => {
      // Tab-specific attribute filters
      const attributeMatch = Object.entries(filters.attributes).every(
        ([tab, attributes]) => {
          return Object.entries(attributes).every(([key, values]) => {
            if (values.length === 0) return true; // No filter applied
            const storeValue = tableConfig[tab].getData(store)[key];
            return values.includes(storeValue);
          });
        }
      );

      return attributeMatch;
    });
  }, [filters]);
  if (loading) {
    return (
      <div style={{ position: 'fixed', top: '0', left: '0' }}>
        <LoadingLayout />
      </div>
    );
  }

  return (
    <>
      <NavBar showSearchInput={false} showMenuIcon={false} />
      <PageHeader breadcrumbs={breadcrumbs} />
      <Box sx={{ display: 'flex' }}>
        <Box
          component="main"
          sx={{
            flexGrow: 1,
            p: 1,
            width: '100%',
            maxWidth: 'none',
          }}
        >
          <Box>
            <PortfolioTable
              stores={filteredStores}
              filters={filters}
              setFilters={setFilters}
              totalCount={filteredStores.length}
            />
          </Box>
        </Box>
      </Box>
    </>
  );
}
portfolioTable.jsx:
import React, { useState } from 'react';
import {
  Table,
  Box,
  TableBody,
  TableCell,
  TableContainer,
  TableSortLabel,
  TableHead,
  TableRow,
  ListItemText,
  OutlinedInput,
  Checkbox,
  TextField,
  Button,
  Typography,
  Accordion,
  AccordionSummary,
  AccordionDetails,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  TablePagination,
  Paper,
  Grid,
} from '@mui/material';
import { ExpandMore } from '@mui/icons-material';
import { tableConfig } from './mockData/tableConfig';

export default function PortfolioTable({ stores = [] }) {
  const [selectedAttributes, setSelectedAttributes] = useState(['name']); // Store Name is mandatory
  const [sortConfig, setSortConfig] = useState({
    key: null,
    direction: 'none',
  });
  const [page, setPage] = useState(0);
  const [rowsPerPage, setRowsPerPage] = useState(10); // Default rows per page
  const [searchQuery, setSearchQuery] = useState('');
  const [columnFilters, setColumnFilters] = useState(
    // Initialize columnFilters with default values for all selected attributes
    selectedAttributes.reduce((acc, attribute) => {
      acc[attribute] = [];
      return acc;
    }, {})
  );

  const handleAttributeSelection = (attributeId) => {
    const isSelected = selectedAttributes.includes(attributeId);
    if (isSelected && attributeId !== 'name') {
      // Prevent deselecting Store Name
      setSelectedAttributes(
        selectedAttributes.filter((id) => id !== attributeId)
      );
      // Remove the filter for the deselected attribute
      setColumnFilters((prevFilters) => {
        const updatedFilters = { ...prevFilters };
        delete updatedFilters[attributeId];
        return updatedFilters;
      });
    } else if (!isSelected && selectedAttributes.length < 20) {
      setSelectedAttributes([...selectedAttributes, attributeId]);
      // Initialize the filter for the newly selected attribute
      setColumnFilters((prevFilters) => ({
        ...prevFilters,
        [attributeId]: [],
      }));
    }
  };

  const handleSort = (key) => {
    let direction = 'asc';
    if (sortConfig.key === key && sortConfig.direction === 'asc') {
      direction = 'desc';
    } else if (sortConfig.key === key && sortConfig.direction === 'desc') {
      direction = 'none';
    }
    setSortConfig({ key, direction });
  };

  const getStoreValue = (store, attributeId) => {
    // Find the view that contains the attribute
    const view = Object.keys(tableConfig).find((view) =>
      tableConfig[view].columns.some((col) => col.id === attributeId)
    );

    // If the view is found, return the value; otherwise, return a default value
    if (view) {
      const value = tableConfig[view].getData(store)[attributeId];
      return value !== undefined ? value.toString() : '-'; // Ensure value is a string
    }
    return '-'; // Default value if the attribute is not found
  };

  const handleChangePage = (event, newPage) => {
    setPage(newPage);
  };

  const handleChangeRowsPerPage = (event) => {
    setRowsPerPage(parseInt(event.target.value, 10));
    setPage(0);
  };

  const handleColumnFilterChange = (attributeId, value) => {
    setColumnFilters((prevFilters) => ({
      ...prevFilters,
      [attributeId]: value,
    }));
  };

  const filteredStores = stores.filter((store) => {
    return selectedAttributes.every((attribute) => {
      const filterValues = columnFilters[attribute] || [];
      if (filterValues.length === 0) return true; // No filter applied
      const storeValue = getStoreValue(store, attribute)?.toLowerCase() || '';
      return filterValues.some((filterValue) =>
        storeValue.includes(filterValue.toString().toLowerCase())
      );
    });
  });

  const sortedStores = [...filteredStores].sort((a, b) => {
    if (sortConfig.direction === 'none') return 0;

    const aValue = getStoreValue(a, sortConfig.key);
    const bValue = getStoreValue(b, sortConfig.key);

    if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
    if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
    return 0;
  });

  const paginatedStores = sortedStores.slice(
    page * rowsPerPage,
    page * rowsPerPage + rowsPerPage
  );

  const filteredColumns = Object.keys(tableConfig).reduce((acc, view) => {
    const columns = tableConfig[view].columns.filter((column) =>
      column.label.toLowerCase().includes(searchQuery.toLowerCase())
    );
    if (columns.length > 0) {
      acc[view] = columns;
    }
    return acc;
  }, {});

  const resetSelections = () => {
    setSelectedAttributes(['name']); // Reset to only storeName
    setColumnFilters({ name: [] }); // Clear all filters except for "name"
  };

  return (
    <Grid container spacing={2} sx={{ height: '100%', p: 0 }}>
      {/* Permanent Sidebar */}
      <Grid item xs={12} md={2.5} sx={{ height: '100%' }}>
        <Paper
          sx={{ height: '100%', p: 1, overflowY: 'auto', borderRadius: 0 }}
        >
          {/* <Typography variant="h6" sx={{ mb: 2 }}>
            Select Attributes (Max of 20)
          </Typography> */}

          <TextField
            variant="outlined"
            size="small"
            placeholder="Search attributes..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            fullWidth
            sx={{ mb: 2 }}
          />

          <Box sx={{ maxHeight: '100vh', overflowY: 'auto' }}>
            {Object.keys(filteredColumns).map((view) => (
              <Accordion key={view}>
                <AccordionSummary expandIcon={<ExpandMore />}>
                  <Typography variant="subtitle1" sx={{ fontWeight: 'bold' }}>
                    {view}
                  </Typography>
                </AccordionSummary>
                <AccordionDetails>
                  {filteredColumns[view].map((column) => (
                    <Box
                      key={column.id}
                      sx={{ display: 'flex', alignItems: 'center' }}
                    >
                      <Checkbox
                        checked={selectedAttributes.includes(column.id)}
                        onChange={() => handleAttributeSelection(column.id)}
                        disabled={column.id === 'name'} // Disable deselecting Store Name
                      />
                      <ListItemText primary={column.label} />
                    </Box>
                  ))}
                </AccordionDetails>
              </Accordion>
            ))}
          </Box>

          <Typography variant="body2" sx={{ mt: 2 }}>
            Selected: {selectedAttributes.length} / 20
          </Typography>

          <Box sx={{ mt: 2, display: 'flex', gap: 2 }}>
            <Button variant="outlined" onClick={resetSelections} fullWidth>
              Reset
            </Button>
          </Box>
        </Paper>
      </Grid>

      {/* Main Content Area */}
      <Grid
        item
        xs={12}
        md={9.5}
        sx={{ height: '100%', paddingLeft: '0 !important' }}
      >
        <Paper
          sx={{
            height: '100%',
            display: 'flex',
            flexDirection: 'column',
            borderRadius: 0,
          }}
        >
          {/* Dynamic Table */}
          <TableContainer sx={{ flex: 1, overflow: 'auto' }}>
            <Table stickyHeader sx={{ minWidth: 'auto' }}>
              <TableHead>
                <TableRow>
                  {selectedAttributes
                    .map((attribute) => {
                      const column = Object.keys(tableConfig)
                        .map((view) =>
                          tableConfig[view].columns.find(
                            (col) => col.id === attribute
                          )
                        )
                        .find((col) => col);
                      return column
                        ? { id: column.id, label: column.label }
                        : null;
                    })
                    .filter((column) => column) // Remove null values
                    .map((column) => (
                      <TableCell
                        key={column.id}
                        sx={{
                          backgroundColor: '#eeeeee',
                          border: '1px solid #ddd',
                          whiteSpace: 'nowrap',
                          position: column.id === 'name' ? 'sticky' : 'static',
                          left: 0,
                          zIndex: 10,
                          textAlign: 'left', // Force left alignment
                          minWidth: column.id === 'name' ? '200px' : undefined, // Set minimum width for name column
                          width: column.id === 'name' ? 'auto' : undefined, // Allow other columns to adjust width
                        }}
                      >
                        <Box
                          sx={{
                            display: 'flex',
                            flexDirection: 'column',
                            gap: 1,
                            alignItems: 'flex-start',
                          }}
                        >
                          <TableSortLabel
                            active={sortConfig.key === column.id}
                            direction={
                              sortConfig.key === column.id &&
                              sortConfig.direction !== 'none'
                                ? sortConfig.direction
                                : 'asc'
                            }
                            onClick={() => handleSort(column.id)}
                          >
                            {column.label}
                          </TableSortLabel>
                          {column.id !== 'name' && (
                            <FormControl
                              variant="outlined"
                              size="small"
                              sx={{
                                justifyContent: 'flex-start',
                                width: '100%',
                              }}
                            >
                              <InputLabel>Filter</InputLabel>
                              <Select
                                multiple
                                value={columnFilters[column.id] || []} // Ensure value is always defined
                                onChange={(e) =>
                                  handleColumnFilterChange(
                                    column.id,
                                    e.target.value
                                  )
                                }
                                input={<OutlinedInput label="Filter" />}
                                renderValue={(selected) => {
                                  // Customize the display of selected values
                                  if (selected.length === 0) {
                                    return 'Filter'; // Show "Filter" when no items are selected
                                  }
                                  return `${selected.length} selected`; // Show "X selected" when items are selected
                                }}
                              >
                                {[
                                  ...new Set(
                                    stores.map((store) =>
                                      getStoreValue(store, column.id)
                                    )
                                  ),
                                ].map((value, index) => (
                                  <MenuItem key={index} value={value}>
                                    <Checkbox
                                      checked={columnFilters[
                                        column.id
                                      ]?.includes(value)}
                                    />
                                    <ListItemText primary={value} />
                                  </MenuItem>
                                ))}
                              </Select>
                            </FormControl>
                          )}
                        </Box>
                      </TableCell>
                    ))}
                </TableRow>
              </TableHead>
              <TableBody>
                {paginatedStores.map((store) => (
                  <TableRow key={store.id}>
                    {selectedAttributes
                      .map((attribute) => {
                        const column = Object.keys(tableConfig)
                          .map((view) =>
                            tableConfig[view].columns.find(
                              (col) => col.id === attribute
                            )
                          )
                          .find((col) => col);
                        return column
                          ? {
                              id: column.id,
                              value: getStoreValue(store, column.id),
                            }
                          : null;
                      })
                      .filter((column) => column) // Remove null values
                      .map((column) => (
                        <TableCell
                          key={column.id}
                          style={{
                            backgroundColor: '#fff',
                            border: '1px solid #ddd',
                            whiteSpace: 'nowrap',
                            position:
                              column.id === 'name' ? 'sticky' : 'static',
                            left: 0,
                            zIndex: 10,
                            textAlign: 'left', // Force left alignment
                            minWidth:
                              column.id === 'name' ? '200px' : undefined,
                          }}
                        >
                          {column.value || '-'}
                        </TableCell>
                      ))}
                  </TableRow>
                ))}
              </TableBody>
            </Table>
          </TableContainer>

          <TablePagination
            rowsPerPageOptions={[10, 20, 30]}
            component="div"
            count={filteredStores.length}
            rowsPerPage={rowsPerPage}
            page={page}
            onPageChange={handleChangePage}
            onRowsPerPageChange={handleChangeRowsPerPage}
          />
        </Paper>
      </Grid>
    </Grid>
  );
}
tableConfig.js:
const tableConfig = {
    location: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'province', label: 'Province' },
        { id: 'region', label: 'WM Region' },
        { id: 'status', label: 'Store Status' },
        { id: 'market', label: 'Market' },
        { id: 'city', label: 'City' },
        { id: 'banner', label: 'Banner' },
        { id: 'originalGoFY', label: 'Original GO FY' },
        { id: 'scGoFY', label: 'SC GO FY' },
        { id: 'scType', label: 'SC TYPE' },
        { id: 'ageOfBox', label: 'Age of Box' },
        { id: 'lastTouchProjectYear', label: 'Last Touch Project Year' },
        { id: 'lastTouchType', label: 'Last Touch Type' },
        { id: 'lastTouchStatus', label: 'Last Touch Status' },
        { id: 'template', label: 'Template' },
        { id: 'totalStoreSqft', label: 'Total Store SQFT' },
        { id: 'acquisitionHistory', label: 'Acquisition History' },
        { id: 'storeFormatBN', label: 'Store Format BN' },
        { id: 'storeFormatBCN', label: 'Store Format BCN' },
        { id: 'storeFormatDiv1', label: 'Store Format Div 1' },
        { id: 'storeFormatSC', label: 'Store Format SC' },
        { id: 'originalGoDate', label: 'Original GO Date' },
        { id: 'scGoDate', label: 'SC GO Date' },
        { id: 'lastTouchGoDate', label: 'Last Touch GO Date' },
      ],
      getData: (store) => ({
        name: store.name,
        province: store.province,
        region: store.region,
        status: store.status,
        market: store.location.market || '-',
        city: store.location.city,
        banner: store.location.banner || '-',
        originalGoFY: store.location.originalGoFY || '-',
        scGoFY: store.location.scGoFY || '-',
        scType: store.location.scType || '-',
        ageOfBox: store.location.ageOfBox || '-',
        lastTouchProjectYear: store.location.lastTouchProjectYear || '-',
        lastTouchType: store.location.lastTouchType || '-',
        lastTouchStatus: store.location.lastTouchStatus || '-',
        template: store.location.template || '-',
        totalStoreSqft: store.location.totalStoreSqft || '-',
        acquisitionHistory: store.location.acquisitionHistory || '-',
        storeFormatBN: store.location.storeFormatBN ? 'Yes' : 'No',
        storeFormatBCN: store.location.storeFormatBCN ? 'Yes' : 'No',
        storeFormatDiv1: store.location.storeFormatDiv1 ? 'Yes' : 'No',
        storeFormatSC: store.location.storeFormatSC ? 'Yes' : 'No',
        originalGoDate: store.location.originalGoDate || '-',
        scGoDate: store.location.scGoDate || '-',
        lastTouchGoDate: store.location.lastTouchGoDate || '-',
      }),
    },
    building: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'size', label: 'Size' },
        { id: 'yearBuilt', label: 'Year Build' },
        { id: 'lastRenovated', label: 'Last Renovated' },
        { id: 'ownedVsLeased', label: 'Owned VS Leased' },
        { id: 'mallStore', label: 'Mall Store' },
        { id: 'mallEntrances', label: 'Mall Entrances' },
        { id: 'securityEntranceGates', label: 'Security Entrance Gates' },
        { id: 'shoppingCentreType', label: 'Shopping Centre Type' },
        {
          id: 'assetProtectionSecurityRoom',
          label: 'Asset Protection Security Room',
        },
        { id: 'floors', label: 'Number of Floors' },
        { id: 'hasBasement', label: 'Basement' },
        {
          id: 'receivingOnDifferentFloor',
          label: 'Receiving on Different Floor',
        },
        { id: 'hasMezzanine', label: 'Mezzanine' },
        { id: 'freightElevators', label: 'Freight Elevators' },
        { id: 'customerElevatorLocation', label: 'Customer Elevator Location' },
        { id: 'verticalTransportation', label: 'Vertical Transportation' },
        { id: 'hasShoppingCartMovator', label: 'Shopping Cart Movator' },
        { id: 'cartCorral', label: 'Cart Corral' },
      ],
      getData: (store) => ({
        name: store.name,
        size: store.building.size || '-',
        floors: store.building.floors || '-',
        yearBuilt: store.building.yearBuilt || '-',
        lastRenovated: store.building.lastRenovated || '-',
        ownedVsLeased: store.building.ownedVsLeased || '-',
        mallStore: store.building.mallStore ? 'Yes' : 'No',
        mallEntrances: store.building.mallEntrances || '0',
        securityEntranceGates: store.building.securityEntranceGates || '0',
        shoppingCentreType: store.building.shoppingCentreType || '-',
        assetProtectionSecurityRoom:
          store.building.assetProtectionSecurityRoom || '-',
        hasBasement: store.building.hasBasement ? 'Yes' : 'No',
        receivingOnDifferentFloor: store.building.receivingOnDifferentFloor
          ? 'Yes'
          : 'No',
        hasMezzanine: store.building.hasMezzanine ? 'Yes' : 'No',
        freightElevators: store.building.freightElevators || '0',
        customerElevatorLocation: store.building.customerElevatorLocation || '-',
        verticalTransportation: store.building.verticalTransportation || '-',
        hasShoppingCartMovator: store.building.hasShoppingCartMovator
          ? 'Yes'
          : 'No',
        cartCorral: store.building.cartCorral || '-',
      }),
    },
    site: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'parkingSpaces', label: 'Parking Spaces' },
        { id: 'accessibility', label: 'Accessibility' },
        { id: 'accessibleSpaces', label: 'Accessible Spaces' },
        { id: 'expectingMotherSpaces', label: 'Expecting Mother Spaces' },
        { id: 'greenParkingSpaces', label: 'Green Parking Spaces' },
        { id: 'chargingStations', label: 'Charging Stations' },
        { id: 'cartCorralExterior', label: 'Cart Corral Exterior' },
        { id: 'parkingLocation', label: 'Parking Location' },
        { id: 'hoursOfOperation', label: 'Hours of Operation' },
      ],
      getData: (store) => ({
        name: store.name,
        parkingSpaces: store.site.parkingSpaces || '-',
        accessibility: store.site?.accessibility?.join(', ') || '-',
        accessibleSpaces: store.site.accessibleSpaces || '-',
        expectingMotherSpaces: store.site.expectingMotherSpaces || '-',
        greenParkingSpaces: store.site.greenParkingSpaces || '-',
        chargingStations: store.site.chargingStations || '0',
        cartCorralExterior: store.site.cartCorralExterior || '-',
        parkingLocation: store.site.parkingLocation || '-',
        hoursOfOperation: store.site?.hoursOfOperation || '-',
      }),
    },
    salesFloor: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'size', label: 'Size' },
        { id: 'departments', label: 'Departments' },
        { id: 'checkoutCounters', label: 'Checkout Counters' },
        { id: 'foodLocation', label: 'Food Location' },
        { id: 'flooring', label: 'Flooring' },
        { id: 'woodgrainType', label: 'Woodgrain Type' },
        { id: 'hasGardenCenter', label: 'Has Garden Center' },
        { id: 'hasHoseBib', label: 'Has Hose Bib' },
      ],
      getData: (store) => ({
        name: store.name,
        size: store.salesFloor.size || '0',
        departments: store.salesFloor.departments?.join(', ') || '-',
        checkoutCounters: store.salesFloor.checkoutCounters || '0',
        foodLocation: store.salesFloor.foodLocation || '-',
        flooring: store.salesFloor.flooring || '-',
        woodgrainType: store.salesFloor.woodgrainType || '-',
        hasGardenCenter: store.salesFloor.hasGardenCenter ? 'Yes' : 'No',
        hasHoseBib: store.salesFloor.hasHoseBib ? 'Yes' : 'No',
      }),
    },
    food: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'hasRestaurant', label: 'Restaurant' },
        { id: 'hasBakery', label: 'Bakery' },
        { id: 'bakeryLocation', label: 'Bakery Location' },
        { id: 'hasDelicatessen', label: 'Delicates' },
        { id: 'hasSushi', label: 'Sushi' },
        { id: 'sushiVendor', label: 'Sushi Vendor' },
        { id: 'hasServiceDeli', label: 'Service Deli' },
        { id: 'hasDeliHMRScreens', label: 'Deli HMR Screens' },
        { id: 'specialtyFoods', label: 'Specialty Foods' },
      ],
      getData: (store) => ({
        name: store.name,
        hasRestaurant: store.food.hasRestaurant ? 'Yes' : 'No',
        hasBakery: store.food.hasBakery ? 'Yes' : 'No',
        bakeryLocation: store.food.bakeryLocation || '-',
        hasDelicatessen: store.food.hasDelicatessen ? 'Yes' : 'No',
        hasSushi: store.food.hasSushi ? 'Yes' : 'No',
        sushiVendor: store.food.sushiVendor || '-',
        hasServiceDeli: store.food.hasServiceDeli ? 'Yes' : 'No',
        hasDeliHMRScreens: store.food.hasDeliHMRScreens ? 'Yes' : 'No',
        specialtyFoods: store.food.specialtyFoods?.join(', ') || '-',
      }),
    },
    pharmacy: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'isPresent', label: 'Present' },
        { id: 'hasClinic', label: 'Clinic' },
        { id: 'location', label: 'Location' },
        { id: 'tier', label: '1 Tier or 2 Tier' },
        { id: 'hasSeating', label: 'Seating' },
        { id: 'consultationRooms', label: 'Consultation Rooms' },
        { id: 'services', label: 'Services' },
      ],
      getData: (store) => ({
        name: store.name,
        isPresent: store.pharmacy.isPresent ? 'Yes' : 'No',
        hasClinic: store.pharmacy.hasClinic ? 'Yes' : 'No',
        location: store.pharmacy.location || '-',
        tier: store.pharmacy.tier || '-',
        hasSeating: store.pharmacy.hasSeating ? 'Yes' : 'No',
        consultationRooms: store.pharmacy.consultationRooms || '0',
        services: store.pharmacy.services?.join(', ') || '-',
      }),
    },
    marketing: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'promotions', label: 'Promotions' },
        { id: 'specialEvents', label: 'Special Events' },
        { id: 'demographics', label: 'Demographics' },
        { id: 'hasMinale', label: 'Minale' },
        { id: 'hasEnchilada', label: 'Enchilada' },
        { id: 'hasSwipeUp', label: 'Swipe Up' },
        { id: 'hasPreMinale', label: 'Pre Minale' },
        { id: 'hasLitFittingRoom', label: 'Lit Fitting Room' },
      ],
      getData: (store) => ({
        name: store.name,
        promotions: store.marketing.promotions?.join(', ') || '-',
        specialEvents: store.marketing.specialEvents?.join(', ') || '-',
        demographics: store.marketing.demographics || '-',
        hasMinale: store.marketing.hasMinale ? 'Yes' : 'No',
        hasEnchilada: store.marketing.hasEnchilada ? 'Yes' : 'No',
        hasSwipeUp: store.marketing.hasSwipeUp ? 'Yes' : 'No',
        hasPreMinale: store.marketing.hasPreMinale ? 'Yes' : 'No',
        hasLitFittingRoom: store.marketing.hasLitFittingRoom ? 'Yes' : 'No',
      }),
    },
    backroom: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'size', label: 'Size' },
        { id: 'hasloadingDocks', label: 'Loading Docks' },
        { id: 'receivingAreas', label: 'Receiving Areas' },
        { id: 'ceilingHeight', label: 'Backroom Ceiling - Height' },
        { id: 'hasMultiHeightCeiling', label: 'Backroom Ceiling - Multi-Height' },
        { id: 'highSteelPalletSpots', label: 'High-Steel Pallet Spots' },
        { id: 'cagesLockups', label: 'Cages/Lock-ups' },
        { id: 'cblTerminals', label: 'CBL Terminals' },
        { id: 'storageCapacity', label: 'Storage Capacity' },
        { id: 'securityFeatures', label: 'Security Features' },
      ],
      getData: (store) => ({
        name: store.name,
        size: store.backroom.size || '-',
        hasloadingDocks: store.backroom.hasloadingDocks || '0',
        receivingAreas: store.backroom.receivingAreas || '0',
        ceilingHeight: store.backroom.ceilingHeight || '-',
        hasMultiHeightCeiling: store.backroom.hasMultiHeightCeiling
          ? 'Yes'
          : 'No',
        highSteelPalletSpots: store.backroom.highSteelPalletSpots || '0',
        cagesLockups: store.backroom.cagesLockups || '0',
        cblTerminals: store.backroom.cblTerminals || '0',
        storageCapacity: store.backroom.storageCapacity || '-',
        securityFeatures: store.backroom.securityFeatures?.join
          ? store.backroom.securityFeatures.join(', ')
          : '-',
      }),
    },
    omni: {
      columns: [
        { id: 'name', label: 'Store Name' },
        { id: 'parkingSpaces', label: 'Parking Spaces' },
        { id: 'orangeBranding', label: 'Orange Branding' },
        { id: 'directAccess', label: 'Direct Access' },
        { id: 'vanLoading', label: 'Van Loading' },
        { id: 'hasMobileCheckIn', label: 'Mobile Check-In' },
        { id: 'mobileCheckIn', label: 'Mobile Check In' },
      ],
      getData: (store) => ({
        name: store.name,
        parkingSpaces: store.omni?.parkingSpaces || '-',
        orangeBranding: store.omni?.orangeBranding || '-',
        directAccess: store.omni?.directAccess || '-',
        vanLoading: store.omni?.vanLoading || '-',
        mobileCheckIn: store.omni?.hasMobileCheckIn
          ? store.omni.mobileCheckInType
          : 'No',
      }),
    },
  };
  
  export { tableConfig };
  